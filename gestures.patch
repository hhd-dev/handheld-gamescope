--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -72,6 +72,8 @@
 
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 
+extern bool env_to_bool(const char *env);
+
 struct wlserver_t wlserver = {
 	.touch_down_ids = {}
 };
@@ -389,19 +391,20 @@
 	wlserver_mousemotion(event->unaccel_dx, event->unaccel_dy, event->time_msec);
 }
 
+static uint32_t s_ftimestamp = 1;
+
 void wlserver_open_steam_menu( bool qam )
 {
 	gamescope_xwayland_server_t *server = wlserver_get_xwayland_server( 0 );
 	if (!server)
 		return;
 
-	uint32_t keycode = qam ? XK_2 : XK_1;
+	uint32_t keycode = qam ? KEY_2 : KEY_1;
 
-	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), XK_Control_L ), True, CurrentTime);
-	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), keycode ), True, CurrentTime);
-
-	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), keycode ), False, CurrentTime);
-	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), XK_Control_L ), False, CurrentTime);
+	wlserver_key(KEY_LEFTCTRL, true, ++s_ftimestamp);
+	wlserver_key(keycode, true, ++s_ftimestamp);
+	wlserver_key(keycode, false, ++s_ftimestamp);
+	wlserver_key(KEY_LEFTCTRL, false, ++s_ftimestamp);
 }
 
 static void wlserver_handle_pointer_button(struct wl_listener *listener, void *data)
@@ -2445,6 +2448,36 @@
 
 			if ( bAlwaysWarpCursor )
 				wlserver_mousewarp( tx, ty, time, false );
+
+			if ( !env_to_bool(getenv("GAMESCOPE_DISABLE_TOUCH_GESTURES")) ) {
+				bool start_gesture = false;
+	
+				// Round the x-coordinate to the nearest whole number
+				uint32_t roundedCursorX = static_cast<int>(std::round(wlserver.mouse_surface_cursorx));
+				// Grab 2% of the display to be used for the edge range
+				double edge_range = g_nOutputWidth * 0.02;
+	
+				// if the touch cursor x position is less or equal to the range then start the gesture for left to right
+				if (roundedCursorX <= edge_range) {
+					start_gesture = true;
+				}
+				// if the touch cursor x position is the output width minus the edge range value then we are doing right to left
+				if (roundedCursorX >= g_nOutputWidth - edge_range) {
+					start_gesture = true;
+				}
+				// when the gesture is started and we are moving to the end of the edge range open home
+				if (start_gesture && roundedCursorX >= 1 && roundedCursorX <= edge_range) {
+					wl_log.infof("Detected Home gesture");
+					wlserver_open_steam_menu(false);
+					start_gesture = false;
+				}
+				// when the gesture is started and we are moving from the output width minus the edge range to the output width open QAM
+				if (start_gesture && roundedCursorX >= g_nOutputWidth - edge_range && roundedCursorX <= g_nOutputWidth ) {
+					wl_log.infof("Detected QAM gesture");
+					wlserver_open_steam_menu(true);
+					start_gesture = false;
+				}
+			}
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
 		{
